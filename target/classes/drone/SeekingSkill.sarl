/** 
 * 
 */
package drone

import io.sarl.core.Logging
import java.util.List
import javax.vecmath.Vector3f

/** 
 * @author Alexandre
 * 
 */
skill SeekingSkill implements Moving {
	uses Logging

	def install {
		// Function invoked when the skill is installed in the owner.
		// You should put all the initialization statements in this block of code.
		info("Installing the skill")
	}

	def uninstall {
		// Function invoked when the skill is uninstalled from the owner.
		// You should put all the resource release statements in this block of code.
		info("Uninstalling the skill")
	}
	
	def seekingFixedTarget(accelerationMessage : AccelerationMessage, target : drone.Sphere) : Vector3f {
		info("Frustum : " + accelerationMessage.frustum)
		val body : DroneBody = accelerationMessage.droneBody
		var droneToTargetVector = new Vector3f
		droneToTargetVector.sub(target.position, body.position) // vector from drone to target
		val distanceDroneToTarget : float = droneToTargetVector.length // absolute distance between the drone and target
		
		if (distanceDroneToTarget <= body.stopZone) {
			var stopVector : Vector3f = body.currentSpeed
			stopVector.negate
			return stopVector 	// stop
		} else {
			var newAcc : Vector3f = droneToTargetVector // acceleration to return after some modifications
			newAcc.scale(body.maxAcc.length / newAcc.length) 	// acceleration adjustment to respect max Acceleration
			
			for (var i : int = 0; i < accelerationMessage.frustum.length; i++) { // loop through each obstacle
				newAcc.add(accelerationMessage.frustum.get(i).computeForces(body, target))
			}
			if (distanceDroneToTarget > body.breakZone) {//max speed
				var newAccABS : Vector3f
				var currentSpeedABS : Vector3f
				currentSpeedABS.absolute(body.currentSpeed)
				// speed adjustment to reach max speed respecting max acceleration :
				newAcc.scale((body.currentSpeed.length + Math.min(body.maxSpeed.length - body.currentSpeed.length, body.maxAcc.length)) / newAcc.length)
				newAccABS.absolute(newAcc)
				if(newAccABS.x > body.maxSpeed.x){
					newAcc.scale(body.maxSpeed.x / newAccABS.x)
					newAccABS.absolute(newAcc)
				}
				if(newAccABS.y > body.maxSpeed.y){
					newAcc.scale(body.maxSpeed.y / newAccABS.y)
					newAccABS.absolute(newAcc)
				}
				if( (newAccABS.x - currentSpeedABS.x) > body.maxAcc.x){
					newAcc.scale((currentSpeedABS.x + body.maxAcc.x ) / newAccABS.x)
					newAccABS.absolute(newAcc)
				}
				if ((newAccABS.y - currentSpeedABS.y) > body.maxAcc.y) {
					newAcc.scale((currentSpeedABS.y + body.maxAcc.y ) / newAccABS.y)
				}
				var subAcc : Vector3f
				subAcc.sub(newAcc, body.currentSpeed)
				return subAcc
			} else { // break
				// speed adjustment to break:
				newAcc.scale((body.maxSpeed.length * distanceDroneToTarget / body.breakZone - body.currentSpeed.length) / newAcc.length)
				return newAcc	
			}
			
		}
	}
}

