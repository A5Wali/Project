/** 
 * 
 */
package drone

import javax.vecmath.Point3f
import javax.vecmath.Vector3f

/** 
 * @author Alexandre
 * 
 */
class Cube extends EnvObj {
	
	
	private var width : float
	
	new(){
		super()
		this.width = 0.0f
	}
	
	new(pos : Point3f, w : float){
		super(pos)
		this.width = w
	}
	
	def setWidth(w : float){
		this.width = w
	}
	
	def getWidth() : float {
		this.width
	}
	
	@Override
	def computeForces(body : DroneBody, target : Sphere) : Vector3f {
		val tMax : float = body.TMax // maximum anticipation time before collision
		var droneToObjectVector : Vector3f = new Vector3f // vector from drone to object i
		var droneToTargetVector : Vector3f = new Vector3f
		droneToTargetVector.sub(target.position, body.position) // vector from drone to target
		val distanceDroneToTarget : float = droneToTargetVector.length // absolute distance between the drone and target
		var newAcc : Vector3f = new Vector3f // acceleration to return after some modifications
		val currentSpeed : float = body.currentSpeed.length
		var distanceOfObjectToPath : float // ditance between object i to droneToTargetPath
			var crossProduct : Vector3f = new Vector3f
		var distanceDroneToObject : float // distance drone to object i
		var objectToTargetVector : Vector3f = new Vector3f
		var timeToCollision : float
		var slidingForceH : Vector3f = new Vector3f
		var slidingForceV : Vector3f = new Vector3f
		var slidingForceD : Vector3f = new Vector3f
		var slidingForce : Vector3f = new Vector3f
//		val scaledDroneToTargetVectorLength : float = droneToTargetVector.length / 5
		val protectingSphere : float = 2.5f
		var repulsiveForce : Vector3f = new Vector3f
		val halfSquare3 : float = 0.87f
		val objectRadius : float = this.width * halfSquare3 + (body as Cube).width

		droneToObjectVector.sub(this.position, body.position)
		crossProduct.cross(droneToObjectVector, droneToTargetVector)
		distanceOfObjectToPath = crossProduct.length / distanceDroneToTarget
		distanceDroneToObject = droneToObjectVector.length
		//println("--length : " + distanceDroneToObject + "\n\r Drone pos : " + body.position + "\n\r CubePos : " + this.position)
		// collision detection:
		
		
		if (distanceOfObjectToPath < objectRadius) {
			distanceDroneToObject = droneToObjectVector.length
			timeToCollision = distanceDroneToObject / currentSpeed
			objectToTargetVector.sub(target.position, this.position)

			// Sliding Force:
			if ((distanceDroneToObject < distanceDroneToTarget) && (objectToTargetVector.length < distanceDroneToTarget) && (timeToCollision < tMax)) { // = the object is between target and drone & we are in anticipation time
				// Horizontal sliding Force:
				println("Sliding force")
				println("dist : " + distanceDroneToObject)
				slidingForceH.cross(droneToObjectVector, new Vector3f(0, 1, 0))
				if ((slidingForceH.dot(droneToTargetVector) ) < 0 || (slidingForceH.dot(droneToTargetVector) ) > 0.8f) {
					slidingForceH.negate
				}

				// Vertical sliding Force:
				slidingForceV.cross(droneToObjectVector, new Vector3f(0, 0, 1))
				if((slidingForceV.dot(droneToTargetVector) ) < 0 || (slidingForceV.dot(droneToTargetVector) ) > 0.8f)
				{
					slidingForceV.negate
				}

				// Depth sliding Force:
				slidingForceD.cross(droneToObjectVector, new Vector3f(1, 0, 0))
				if((slidingForceD.dot(droneToTargetVector) ) < 0 || (slidingForceD.dot(droneToTargetVector) ) > 0.8f)
				{
					slidingForceD.negate
				}
				
				slidingForce.add(slidingForceV, slidingForceH)
				slidingForce.add(slidingForceD)
				slidingForce.scale((objectRadius - distanceOfObjectToPath)*5 / slidingForce.length)
				slidingForce.scale((5 / ((timeToCollision / 10) * (timeToCollision / 10))) - (50 / tMax))
				newAcc.add(slidingForce)
			}
		}

		// We add a Repulsive force in Protected area:
		if (distanceDroneToObject - objectRadius < protectingSphere) {
			repulsiveForce = droneToObjectVector
			repulsiveForce.negate
			repulsiveForce.scale(body.currentSpeed.length / (repulsiveForce.length - objectRadius))
			repulsiveForce.scale(protectingSphere / (distanceDroneToObject-objectRadius-1))
			newAcc.add(repulsiveForce)
		}
		
		return newAcc
	}
}
