/** 
 * 
 */
package drone

import javax.vecmath.Point3f
import javax.vecmath.Vector3f
import java.lang.Math

/** 
 * @author Alexandre
 * 
 */
class Cube extends EnvObj {
	
	
	private var width : float
	
	new(){
		super()
		this.width = 0.0f
	}
	
	new(pos : Point3f, w : float){
		super(pos)
		this.width = w
	}
	
	def setWidth(w : float){
		this.width = w
	}
	
	def getWidth() : float {
		this.width
	}
	
	@Override
	def computeForces(body : DroneBody, target : Sphere, droneToTargetVector : Vector3f, distanceDroneToTarget : float, currentSpeed : float) : Vector3f {
		
	
		
		var newAcc : Vector3f = new Vector3f // acceleration to return after some modifications
		val objectRadius : float = this.width * 1f + 4.5f*(body as Cube).width // sqrt(3)/2 = 0.87
		var droneToObjectVector : Vector3f = new Vector3f // vector from drone to object i
		droneToObjectVector.sub(this.position, body.position)
		val distanceDroneToObject : float = droneToObjectVector.length // distance drone to object
		var crossProduct : Vector3f = new Vector3f
		crossProduct.cross(droneToObjectVector, body.currentSpeed)
		val distanceOfObjectToPath : float = crossProduct.length / currentSpeed // ditance between object i to droneToTargetPath
		
		//println("--length : " + distanceDroneToObject + "\n\r Drone pos : " + body.position + "\n\r CubePos : " + this.position)
		
		// collision detection:
		if (distanceOfObjectToPath < objectRadius) {
			val timeToCollision : float = (distanceDroneToObject-objectRadius) / currentSpeed
			var objectToTargetVector : Vector3f = new Vector3f
			objectToTargetVector.sub(target.position, this.position)

			// Sliding Force:
			
			// = the object is between target and drone & we are in anticipation time (tmax) :
			if (body.currentSpeed.dot(droneToObjectVector) >= 0f && (timeToCollision < body.TMax)) {
				var FirstPerpendicularVector : Vector3f
				var SecondPerpendicularVector : Vector3f = new Vector3f
				var slidingForce : Vector3f = new Vector3f

				FirstPerpendicularVector = getPerpendicularVector(droneToObjectVector)
				FirstPerpendicularVector.normalize
				SecondPerpendicularVector.cross(droneToObjectVector, FirstPerpendicularVector)
				SecondPerpendicularVector.normalize
				
				// Horizontal sliding Force:
				if ((FirstPerpendicularVector.dot(droneToTargetVector) ) < 0) {
					FirstPerpendicularVector.negate
				}

				// Vertical sliding Force:
				if ((SecondPerpendicularVector.dot(droneToTargetVector) ) < 0) {
					SecondPerpendicularVector.negate
				}

				slidingForce.add(FirstPerpendicularVector, SecondPerpendicularVector)
				slidingForce.normalize
				// for adjustment change the '5' value :
				slidingForce.scale(
					Math.abs(
						((Math.pow(body.TMax * (objectRadius - distanceOfObjectToPath), 1) as float) /
					( Math.pow((timeToCollision * (distanceDroneToObject - objectRadius)), 1) as float)) * 3f))
				newAcc.add(slidingForce)
			}	
		}

			// We add a Repulsive force in Protected area:
			val realDistanceDroneToObject : float = Math.max(distanceDroneToObject - (objectRadius - 3.5f*(body as Cube).width), 0.001f)
			if (realDistanceDroneToObject < body.protectingSphere) {
				var repulsiveForce : Vector3f = new Vector3f
				repulsiveForce = droneToObjectVector
				repulsiveForce.negate
				repulsiveForce.normalize
				// for adjustment change the '5' value :
	
					repulsiveForce.scale(
						Math.abs(
						((Math.pow(body.protectingSphere, 1) as float) /
							(Math.pow(realDistanceDroneToObject, 1) as float)) * 0.8f))
					newAcc.add(repulsiveForce)
			
			
		}
		
		return newAcc
	}
}