/** 
 * 
 */
package drone

import io.sarl.core.Logging
import java.util.List
import javax.vecmath.Vector3f

/** 
 * @author Alexandre
 * 
 */
skill SeekingSkill implements Moving {
	uses Logging

	def install {
		// Function invoked when the skill is installed in the owner.
		// You should put all the initialization statements in this block of code.
		info("Installing the skill")
	}

	def uninstall {
		// Function invoked when the skill is uninstalled from the owner.
		// You should put all the resource release statements in this block of code.
		info("Uninstalling the skill")
	}
	
	def seekingFixedTarget(accelerationMessage : AccelerationMessage, target : drone.Sphere) : Vector3f {
		//info("Frustum : " + accelerationMessage.frustum)
		val body : DroneBody = accelerationMessage.droneBody
		var droneToTargetVector = new Vector3f
		droneToTargetVector.sub(target.position, body.position) // vector from drone to target
		val distanceDroneToTarget : float = droneToTargetVector.length // absolute distance between the drone and target
		
		if (distanceDroneToTarget <= body.stopZone) {
			var stopVector : Vector3f = body.currentSpeed
			stopVector.negate
			return stopVector 	// stop
		} else {

			var newAcc : Vector3f = droneToTargetVector // acceleration to return after some modifications
			newAcc.scale(Math.max(Math.max(body.maxAcc.x, body.maxAcc.y), body.maxAcc.z) / newAcc.length) // acceleration adjustment to respect max Acceleration

			if (distanceDroneToTarget > body.breakZone) { // max speed
			
				for (var i : int = 0; i < accelerationMessage.frustum.length; i++) { // loop through each obstacle
				newAcc.add(accelerationMessage.frustum.get(i).computeForces(body, target))
				}
			
				var newAccABS : Vector3f = new Vector3f
				var currentSpeedABS : Vector3f = new Vector3f
				currentSpeedABS.absolute(body.currentSpeed)
				// speed adjustment to reach max speed respecting max acceleration :
				newAcc.scale((body.currentSpeed.length + Math.min(body.maxSpeed.length - body.currentSpeed.length, body.maxAcc.length)) / newAcc.length)
				newAccABS.absolute(newAcc)
				if(newAccABS.x > body.maxSpeed.x){
					newAcc.scale(body.maxSpeed.x / newAccABS.x)
					newAccABS.absolute(newAcc)
				}
				if(newAccABS.y > body.maxSpeed.y){
					newAcc.scale(body.maxSpeed.y / newAccABS.y)
					newAccABS.absolute(newAcc)
				}
				if (newAccABS.z > body.maxSpeed.z) {
					newAcc.scale(body.maxSpeed.z / newAccABS.z)
					newAccABS.absolute(newAcc)
				}

				var subAcc : Vector3f = new Vector3f
				subAcc.sub(newAcc, body.currentSpeed)
				var subAccABS : Vector3f = new Vector3f
				subAccABS.absolute(subAcc)

				if (subAccABS.x > body.maxAcc.x) {
					subAcc.scale(body.maxAcc.x / subAccABS.x)
					subAccABS.absolute(newAcc)
				}
				if (subAccABS.y > body.maxAcc.y) {
					subAcc.scale(body.maxAcc.y / subAccABS.y)
					subAccABS.absolute(newAcc)
				}
				if (subAccABS.z > body.maxAcc.z) {
					subAcc.scale(body.maxAcc.z / subAccABS.z)
				}
				
				info("maxAcc : " + body.maxAcc)
				info("Acc : " + subAcc)
				return subAcc
			} else { // break
				// speed adjustment to break:
				
				newAcc.scale(
					(body.maxSpeed.length * Math.sqrt(distanceDroneToTarget / body.breakZone) as float))

				newAcc.sub(newAcc, body.currentSpeed)
				
				var newAccABS : Vector3f = new Vector3f
				newAccABS.absolute(newAcc)

				if (newAccABS.x > body.maxAcc.x) {
					newAcc.scale(body.maxAcc.x / newAccABS.x)
					newAccABS.absolute(newAcc)
				}
				if (newAccABS.y > body.maxAcc.y) {
					newAcc.scale(body.maxAcc.y / newAccABS.y)
					newAccABS.absolute(newAcc)
				}
				if (newAccABS.z > body.maxAcc.z) {
					newAcc.scale(body.maxAcc.z / newAccABS.z)
				}
				
				
				return newAcc	
			}
			
		}
	}
}

