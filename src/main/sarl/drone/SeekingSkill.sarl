/** 
 * 
 */
package drone

import io.sarl.core.Logging
import java.util.List
import javax.vecmath.Vector3f

/** 
 * @author Alexandre
 * 
 */
skill SeekingSkill implements Moving {
	uses Logging

	def install {
		// Function invoked when the skill is installed in the owner.
		// You should put all the initialization statements in this block of code.
		info("Installing the skill")
	}

	def uninstall {
		// Function invoked when the skill is uninstalled from the owner.
		// You should put all the resource release statements in this block of code.
		info("Uninstalling the skill")
	}
	
	def seekingFixedTarget(accelerationMessage : AccelerationMessage, target : drone.Sphere) : Vector3f {
		info("Frustum : " + accelerationMessage.frustum)
		val body : DroneBody = accelerationMessage.droneBody
		var droneToTargetVector = new Vector3f
		droneToTargetVector.sub(target.position, body.position) // vector from drone to target
		val distanceDroneToTarget : float = droneToTargetVector.length // absolute distance between the drone and target
		
		if (distanceDroneToTarget <= body.stopZone) {
			var stopVector : Vector3f = body.currentSpeed
			stopVector.negate
			return stopVector 	// stop
		} else {
			var newAcc : Vector3f = droneToTargetVector // acceleration to return after some modifications
			newAcc.scale(body.maxAcc / newAcc.length) 	// acceleration adjustment to respect max Acceleration
			
			for (var i : int = 0; i < accelerationMessage.frustum.length; i++) { // loop through each obstacle
				newAcc.add(accelerationMessage.frustum.get(i).computeForces(body, target))
			}
			if (distanceDroneToTarget > body.breakZone) {//max speed
				// speed adjustment to reach max speed respecting max acceleration :
				newAcc.scale(Math.min((body.maxSpeed - body.currentSpeed.length),body.maxAcc) / newAcc.length) 	
			} else { // break
				// speed adjustment to break:
				newAcc.scale((body.maxSpeed * distanceDroneToTarget / body.breakZone - body.currentSpeed.length) / newAcc.length) 		
			}
			return newAcc
		}
	}
}

