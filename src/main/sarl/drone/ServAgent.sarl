/** 
 * 
 */
package drone
/** 
 * @author Cl√©ment
 * 
 */

import com.google.gson.Gson
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import java.io.BufferedReader
import java.io.PrintWriter
import java.net.ServerSocket
import java.net.Socket
import java.util.HashMap
import java.nio.charset.Charset
import java.nio.file.Paths
import java.nio.file.Files
import java.nio.charset.StandardCharsets

event SendMessage {
	var message : Message
	new (m : Message) {
		this.message = m;
	}
}

event ReadMessage
event CloseServer
event StopBuffer
event ReceivedMessage{
	var message : Message
	new (m : Message){
		message = m
	}
}


agent ServAgent {

	uses Logging, Lifecycle, DefaultContextInteractions
	
	var socketServer : ServerSocket
	var socket : Socket
	var reader : BufferedReader
	var writer : PrintWriter
	var gson : Gson
	
	def sendMessage(m : Message){
		emit (new SendMessage(m))
	}
	
	def readMessage(){
		emit (new ReadMessage())
	}

	on Initialize {

		info("Server Agent started")
		val port = 8080;
		gson = new Gson()
		var dir = System.getProperty("user.dir");
		var rep = dir.replace("\\", "/") + "/UnityLaucher_Data/NbDrones.txt"
		var nbString = readFile(rep, StandardCharsets.UTF_8)
		var nbDrones = Integer.parseInt(nbString);
		socketServer = new ServerSocket(port)
		socket = socketServer.accept()
	 	info("Client connected to server")
		spawn(BufferReaderAgent, socket)
		writer = new PrintWriter(socket.getOutputStream());
		for (var i : int = 0; i < nbDrones; i++) 
			spawn(DroneAgent)
		
		
		//		spawn(testAgent2)
	 	

	}

	def readFile(path : String, encoding : Charset) : String
	{
		Files.readAllLines(Paths.get(path), encoding).get(0)
//	  var encoded = Files.readAllBytes(Paths.get(path));
//	  return new String(encoded, encoding);
	}
	
	on SendMessage {
		var message = occurrence.message
		var uuid = occurrence.source.getUUID
		
		message.UUID = uuid
		
		var jsonString = gson.toJson(message);
		
		writer.println(jsonString);
		writer.flush
	}
	
	on CloseServer {
		writer.close()
		socket.close()
		socketServer.close()
		killMe
	}
}
